(defun binomial (n k)
  (cond ((= k 0) 1)
        ((= k n) 1)
        (t       (+ (binomial (- n 1) k) (binomial (- n 1) (- k 1))))
  )
)

(defun add-rows (lst1 lst2)
  (cond ((= (length lst1) 1) (list (+ (car lst1) (car lst2))))
        (t (append (list (+ (car lst1) (car lst2))) (add-rows (cdr lst1) (cdr lst2))))
  )
)

(defun pascal (n)
  (cond ((= n 0) (list 1))
        (t       (let ((row (pascal (- n 1))))
                      (let ((row1 (cons 0 row))(row2 (append row (list 0))))
                          (add-rows row1 row2))))
  )
)

(defun binomial2 (n k)
  (nth k (pascal n))
)

(defun merge-sort (lst)
  (defun merge_(f s)
    (cond
      ((= (list-length f) 0) s)
      ((= (list-length s) 0) f)
      ((< (car f) (car s)) (append (list (car f)) (merge_ (cdr f) s)))
      ((> (car f) (car s)) (append (list (car s)) (merge_ f (cdr s))))
      ((= (car f) (car s)) (append (list (car f) (car s)) (merge_ (cdr f) (cdr s))))
    )
  )
  (let ((len (list-length lst)))
    (cond
      ((= len 1) lst)
      (t
         (merge_ (merge-sort (subseq lst 0 (ceiling (/ len 2))))
                 (merge-sort (subseq lst (ceiling (/ len 2))))
         )
      )
    )
  )
)

(defun diophantine (a b)
    (cond ((= a 0) (list 0 1 b))
    (t(let ((res (diophantine (mod b a) a)))
        (let ((x (nth 0 res))(y (nth 1 res))(z (nth 2 res)))
            (list (- y (* x (floor b a))) x z))))
    )
)

(defun is-prime (n &optional (x 2))
  (if (or (> x (sqrt n))
	  (and (/= (rem n x) 0)
	       (is-prime n (+ 1 x))))
      (list n)
      nil)
)

(defun prime-factors (n &optional (x 2))
  (if (= n x) (is-prime n)
      (if (and (= (rem n x) 0))
	      (append (list x) (prime-factors (floor n x) x))
	    (prime-factors n (+ 1 x))))
)

(defun coprime (n m)
  (cond ((= 1 (gcd n m)) 1)
        (t               0)
  )
)

(defun phi (k n)
  (cond ((= k n) 0)
        ((= 1 (coprime k n)) (+ 1 (phi (+ k 1) n)))
        (t                        (phi (+ k 1) n))
  )
)

(defun product (lst)
  (cond ((= (length lst) 1) (- 1 (/ (float 1) (car lst))))
        (t   (* (- 1 (/ (float 1) (car lst))) (product (cdr lst))))
  )
)

(defun phi2 (n)
  (round (* n (product (remove-duplicates (prime-factors n)))))
)

(defun primes (k n)
  (cond ((> k n) nil)
        ((is-prime k) (append (is-prime k) (primes (+ k 1) n)))
        (t            (primes (+ k 1) n))
  )
)

(write(time(binomial 15 11)))
(terpri)
(write(time(binomial2 15 11)))
(terpri)
(write(merge-sort(list 11 -1 2 3 10 1 2 7)))
(terpri)
(write(diophantine 254 44))
(terpri)
(write(prime-factors 1386))
(terpri)
(write(time(phi 0 1386)))
(terpri)
(write(time(phi2 1386)))
(terpri)
(write(primes 2 50))